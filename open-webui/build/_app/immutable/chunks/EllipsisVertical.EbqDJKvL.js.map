{"version":3,"file":"EllipsisVertical.EbqDJKvL.js","sources":["../../../../../../src/lib/components/AddFilesPlaceholder.svelte","../../../../../../node_modules/paneforge/dist/internal/utils/lifecycle.js","../../../../../../node_modules/paneforge/dist/internal/utils/store.js","../../../../../../node_modules/paneforge/dist/internal/utils/style.js","../../../../../../node_modules/paneforge/dist/internal/utils/aria.js","../../../../../../node_modules/paneforge/dist/internal/utils/id.js","../../../../../../node_modules/paneforge/dist/internal/constants.js","../../../../../../node_modules/paneforge/dist/internal/utils/storage.js","../../../../../../node_modules/paneforge/dist/internal/utils/object.js","../../../../../../node_modules/paneforge/dist/internal/utils/chain.js","../../../../../../node_modules/paneforge/dist/internal/utils/event.js","../../../../../../node_modules/paneforge/dist/internal/utils/compare.js","../../../../../../node_modules/paneforge/dist/internal/utils/assert.js","../../../../../../node_modules/paneforge/dist/internal/utils/resize.js","../../../../../../node_modules/paneforge/dist/internal/utils/adjust-layout.js","../../../../../../node_modules/paneforge/dist/internal/utils/is.js","../../../../../../node_modules/paneforge/dist/internal/paneforge.js","../../../../../../node_modules/paneforge/dist/components/ctx.js","../../../../../../node_modules/paneforge/dist/components/pane-group.svelte","../../../../../../node_modules/paneforge/dist/components/pane.svelte","../../../../../../node_modules/paneforge/dist/components/pane-resizer.js","../../../../../../node_modules/paneforge/dist/components/pane-resizer.svelte","../../../../../../src/lib/components/common/Drawer.svelte","../../../../../../src/lib/components/icons/EllipsisVertical.svelte"],"sourcesContent":["<script>\n\timport { getContext } from 'svelte';\n\n\texport let title = '';\n\texport let content = '';\n\tconst i18n = getContext('i18n');\n</script>\n\n<div class=\"px-3\">\n\t<div class=\"text-center text-6xl mb-3\">ðŸ“„</div>\n\t<div class=\"text-center dark:text-white text-xl font-semibold z-50\">\n\t\t{#if title}\n\t\t\t{title}\n\t\t{:else}\n\t\t\t{$i18n.t('Add Files')}\n\t\t{/if}\n\t</div>\n\n\t<slot\n\t\t><div class=\"px-2 mt-2 text-center text-sm dark:text-gray-200 w-full\">\n\t\t\t{#if content}\n\t\t\t\t{content}\n\t\t\t{:else}\n\t\t\t\t{$i18n.t('Drop any files here to add to the conversation')}\n\t\t\t{/if}\n\t\t</div>\n\t</slot>\n</div>\n","import { onDestroy } from \"svelte\";\n/**\n * Safely calls `onDestroy` and catches any errors that occur.\n */\nexport function safeOnDestroy(fn) {\n    try {\n        onDestroy(fn);\n    }\n    catch {\n        return fn();\n    }\n}\n","import { isBrowser, safeOnDestroy } from \"./index.js\";\nimport { derived, writable, } from \"svelte/store\";\n/**\n * A utility function that creates a derived store that automatically\n * unsubscribes from its dependencies.\n *\n * Originally written by @tglide for use in Melt UI. <3\n *\n * @template S - The type of the stores object\n * @template T - The type of the derived store\n * @param stores - The stores object to derive from\n * @param fn - The function to derive the store from\n * @returns A derived store that automatically unsubscribes from its dependencies\n */\nexport function derivedWithUnsubscribe(stores, fn) {\n    let unsubscribers = [];\n    const onUnsubscribe = (cb) => {\n        unsubscribers.push(cb);\n    };\n    const unsubscribe = () => {\n        // Call all of the unsubscribe functions from the previous run of the function\n        unsubscribers.forEach((fn) => fn());\n        // Clear the list of unsubscribe functions\n        unsubscribers = [];\n    };\n    const derivedStore = derived(stores, ($storeValues) => {\n        unsubscribe();\n        return fn($storeValues, onUnsubscribe);\n    });\n    safeOnDestroy(unsubscribe);\n    const subscribe = (...args) => {\n        const unsub = derivedStore.subscribe(...args);\n        return () => {\n            unsub();\n            unsubscribe();\n        };\n    };\n    return {\n        ...derivedStore,\n        subscribe,\n    };\n}\n/**\n * A utility function that creates an effect from a set of stores and a function.\n * The effect is automatically cleaned up when the component is destroyed.\n *\n * Originally written by @tglide for use in Melt UI. <3\n *\n * @template S - The type of the stores object\n * @param stores - The stores object to derive from\n * @param fn - The function to run when the stores change\n * @returns A function that can be used to unsubscribe the effect\n */\nexport function clientEffect(stores, fn) {\n    if (!isBrowser)\n        return () => { };\n    // Create a derived store that contains the stores object and an onUnsubscribe function\n    const unsub = derivedWithUnsubscribe(stores, (stores, onUnsubscribe) => {\n        return {\n            stores,\n            onUnsubscribe,\n        };\n    }).subscribe(({ stores, onUnsubscribe }) => {\n        const returned = fn(stores);\n        // If the function returns a cleanup function, call it when the effect is unsubscribed\n        if (returned) {\n            onUnsubscribe(returned);\n        }\n    });\n    // Automatically unsubscribe the effect when the component is destroyed\n    safeOnDestroy(unsub);\n    return unsub;\n}\n/**\n * Given an object of properties, returns an object of writable stores\n * with the same properties and values.\n */\nexport function toWritableStores(properties) {\n    const result = {};\n    Object.keys(properties).forEach((key) => {\n        const propertyKey = key;\n        const value = properties[propertyKey];\n        result[propertyKey] = writable(value);\n    });\n    return result;\n}\n/**\n * Returns a function that can be used to update the values of options\n * in a store based on the modification of a prop.\n */\nexport function getOptionUpdater(options) {\n    return function (key, value) {\n        if (value === undefined)\n            return;\n        const store = options[key];\n        if (store) {\n            store.set(value);\n        }\n    };\n}\n","/**\n * A utility function that converts a style object to a string,\n * which can be used as the value of the `style` attribute for\n * an element.\n *\n * @param style - The style object to convert\n * @returns The style object as a string\n */\nexport function styleToString(style) {\n    return Object.keys(style).reduce((str, key) => {\n        if (style[key] === undefined)\n            return str;\n        return str + `${key}:${style[key]};`;\n    }, \"\");\n}\n/* Global cursor state */\nlet currentState = null;\n/* Global cursor element */\nlet element = null;\n/**\n * Returns the cursor style for a given cursor state.\n */\nexport function getCursorStyle(state) {\n    switch (state) {\n        case \"horizontal\":\n            return \"ew-resize\";\n        case \"horizontal-max\":\n            return \"w-resize\";\n        case \"horizontal-min\":\n            return \"e-resize\";\n        case \"vertical\":\n            return \"ns-resize\";\n        case \"vertical-max\":\n            return \"n-resize\";\n        case \"vertical-min\":\n            return \"s-resize\";\n    }\n}\n/**\n * Resets the global cursor style to the default.\n */\nexport function resetGlobalCursorStyle() {\n    if (element === null)\n        return;\n    document.head.removeChild(element);\n    currentState = null;\n    element = null;\n}\n/**\n * Sets the global cursor style to the given state.\n */\nexport function setGlobalCursorStyle(state) {\n    if (currentState === state)\n        return;\n    currentState = state;\n    const style = getCursorStyle(state);\n    if (element === null) {\n        element = document.createElement(\"style\");\n        document.head.appendChild(element);\n    }\n    element.innerHTML = `*{cursor: ${style}!important;}`;\n}\n/**\n * Computes the flexbox style for a pane given its layout and drag state.\n */\nexport function computePaneFlexBoxStyle({ defaultSize, dragState, layout, paneData, paneIndex, precision = 3, }) {\n    const size = layout[paneIndex];\n    let flexGrow;\n    if (size == null) {\n        // Initial render (before panes have registered themselves)\n        // To support server rendering, fallback to default size\n        flexGrow = defaultSize ?? \"1\";\n    }\n    else if (paneData.length === 1) {\n        //  Single pane group should always fill full width/height\n        flexGrow = \"1\";\n    }\n    else {\n        flexGrow = size.toPrecision(precision);\n    }\n    return styleToString({\n        \"flex-basis\": 0,\n        \"flex-grow\": flexGrow,\n        \"flex-shrink\": 1,\n        // Without this, pane sizes may be unintentionally overridden by their content\n        overflow: \"hidden\",\n        // Disable pointer events inside of a pane during resize\n        // This avoid edge cases like nested iframes\n        \"pointer-events\": dragState !== null ? \"none\" : undefined,\n    });\n}\n","/**\n * A utility function that calculates the `aria-valuemax`, `aria-valuemin`,\n * and `aria-valuenow` values for a pane based on its layout and constraints.\n */\nexport function calculateAriaValues({ layout, panesArray, pivotIndices, }) {\n    let currentMinSize = 0;\n    let currentMaxSize = 100;\n    let totalMinSize = 0;\n    let totalMaxSize = 0;\n    const firstIndex = pivotIndices[0];\n    // A pane's effective min/max sizes also need to account for other pane's sizes.\n    for (let i = 0; i < panesArray.length; i++) {\n        const { constraints } = panesArray[i];\n        const { maxSize = 100, minSize = 0 } = constraints;\n        if (i === firstIndex) {\n            currentMinSize = minSize;\n            currentMaxSize = maxSize;\n        }\n        else {\n            totalMinSize += minSize;\n            totalMaxSize += maxSize;\n        }\n    }\n    const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n    const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);\n    const valueNow = layout[firstIndex];\n    return {\n        valueMax,\n        valueMin,\n        valueNow,\n    };\n}\n","import { nanoid } from \"nanoid/non-secure\";\n/**\n * If an id is provided return it, otherwise generate a new id and return that.\n */\nexport function generateId(idFromProps = null) {\n    if (idFromProps == null)\n        return nanoid(10);\n    return idFromProps;\n}\n","export const LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;\nexport const PRECISION = 10;\n","import { get } from \"svelte/store\";\nimport { LOCAL_STORAGE_DEBOUNCE_INTERVAL } from \"../constants.js\";\n/**\n * Initializes the storage object with the appropriate getItem\n *  and setItem functions depending on the environment (browser or not).\n */\nexport function initializeStorage(storageObject) {\n    try {\n        if (typeof localStorage === \"undefined\") {\n            throw new Error(\"localStorage is not supported in this environment\");\n        }\n        storageObject.getItem = (name) => localStorage.getItem(name);\n        storageObject.setItem = (name, value) => localStorage.setItem(name, value);\n    }\n    catch (err) {\n        // eslint-disable-next-line no-console\n        console.error(err);\n        storageObject.getItem = () => null;\n        storageObject.setItem = () => { };\n    }\n}\n/**\n * Returns the key to use for storing the pane group state in local storage.\n */\nfunction getPaneGroupKey(autoSaveId) {\n    return `paneforge:${autoSaveId}`;\n}\n/**\n * Returns a key to use for storing the pane state in local storage.\n * The key is based on the pane order and constraints.\n */\nfunction getPaneKey(panes) {\n    const sortedPaneIds = panes\n        .map((pane) => {\n        const { constraints, id, idIsFromProps, order } = pane;\n        return idIsFromProps\n            ? id\n            : order\n                ? `${order}:${JSON.stringify(constraints)}`\n                : JSON.stringify(constraints);\n    })\n        .sort()\n        .join(\",\");\n    return sortedPaneIds;\n}\n/**\n * Loads the serialized pane group state from local storage.\n * If the state is not found, returns null.\n */\nfunction loadSerializedPaneGroupState(autoSaveId, storage) {\n    try {\n        const paneGroupKey = getPaneGroupKey(autoSaveId);\n        const serialized = storage.getItem(paneGroupKey);\n        const parsed = JSON.parse(serialized || \"\");\n        if (typeof parsed === \"object\" && parsed !== null) {\n            return parsed;\n        }\n    }\n    catch {\n        // noop\n    }\n    return null;\n}\n/**\n * Loads the pane group state from local storage.\n * If the state is not found, returns null.\n */\nexport function loadPaneGroupState(autoSaveId, panes, storage) {\n    const state = loadSerializedPaneGroupState(autoSaveId, storage) || {};\n    const paneKey = getPaneKey(panes);\n    return state[paneKey] || null;\n}\n/**\n * Saves the pane group state to local storage.\n */\nexport function savePaneGroupState(autoSaveId, panes, paneSizesBeforeCollapse, sizes, storage) {\n    const paneGroupKey = getPaneGroupKey(autoSaveId);\n    const paneKey = getPaneKey(panes);\n    const state = loadSerializedPaneGroupState(autoSaveId, storage) || {};\n    state[paneKey] = {\n        expandToSizes: Object.fromEntries(paneSizesBeforeCollapse.entries()),\n        layout: sizes,\n    };\n    try {\n        storage.setItem(paneGroupKey, JSON.stringify(state));\n    }\n    catch (error) {\n        // eslint-disable-next-line no-console\n        console.error(error);\n    }\n}\nconst debounceMap = {};\n/**\n * Returns a debounced version of the given function.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction debounce(callback, durationMs = 10) {\n    let timeoutId = null;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const callable = (...args) => {\n        if (timeoutId !== null) {\n            clearTimeout(timeoutId);\n        }\n        timeoutId = setTimeout(() => {\n            callback(...args);\n        }, durationMs);\n    };\n    return callable;\n}\n/**\n * Updates the values in local storage based on the current state of\n * the pane group.\n * This function is debounced to limit the frequency of local storage writes.\n */\nexport function updateStorageValues({ autoSaveId, layout, storage, paneDataArrayStore, paneSizeBeforeCollapseStore, }) {\n    const $paneDataArray = get(paneDataArrayStore);\n    // If this pane has been configured to persist sizing\n    // information, save sizes to local storage.\n    if (layout.length === 0 || layout.length !== $paneDataArray.length)\n        return;\n    let debouncedSave = debounceMap[autoSaveId];\n    // Limit frequency of local storage writes.\n    if (debouncedSave == null) {\n        debouncedSave = debounce(savePaneGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);\n        debounceMap[autoSaveId] = debouncedSave;\n    }\n    // Clone mutable data before passing to the debounced function,\n    // else we run the risk of saving an incorrect combination of mutable and immutable values to state.\n    const clonedPaneDataArray = [...$paneDataArray];\n    const $paneSizeBeforeCollapse = get(paneSizeBeforeCollapseStore);\n    const clonedPaneSizesBeforeCollapse = new Map($paneSizeBeforeCollapse);\n    debouncedSave(autoSaveId, clonedPaneDataArray, clonedPaneSizesBeforeCollapse, layout, storage);\n}\n","/**\n * Removes all undefined properties from the given object.\n */\nexport function removeUndefined(obj) {\n    const result = {};\n    for (const key in obj) {\n        const value = obj[key];\n        if (value !== undefined) {\n            result[key] = value;\n        }\n    }\n    return result;\n}\n","/**\n * Executes an array of callback functions with the same arguments.\n * @template T The types of the arguments that the callback functions take.\n * @param n array of callback functions to execute.\n * @returns A new function that executes all of the original callback functions with the same arguments.\n */\nexport function chain(...callbacks) {\n    return (...args) => {\n        for (const callback of callbacks) {\n            if (typeof callback === \"function\") {\n                callback(...args);\n            }\n        }\n    };\n}\n","/**\n * Adds an event listener to the specified target element(s) for the given event(s), and returns a function to remove it.\n * @param target The target element(s) to add the event listener to.\n * @param event The event(s) to listen for.\n * @param handler The function to be called when the event is triggered.\n * @param options An optional object that specifies characteristics about the event listener.\n * @returns A function that removes the event listener from the target element(s).\n */\nexport function addEventListener(target, event, handler, options) {\n    const events = Array.isArray(event) ? event : [event];\n    // Add the event listener to each specified event for the target element(s).\n    events.forEach((_event) => target.addEventListener(_event, handler, options));\n    // Return a function that removes the event listener from the target element(s).\n    return () => {\n        events.forEach((_event) => target.removeEventListener(_event, handler, options));\n    };\n}\n","import { PRECISION } from \"../constants.js\";\n/**\n * Compares two numbers for equality with a given fractional precision.\n */\nexport function areNumbersAlmostEqual(actual, expected, fractionDigits = PRECISION) {\n    return compareNumbersWithTolerance(actual, expected, fractionDigits) === 0;\n}\n/**\n * Compares two numbers with a given tolerance.\n *\n * @returns `-1` if `actual` is less than `expected`, `0` if they are equal,\n * and `1` if `actual` is greater than `expected`.\n */\nexport function compareNumbersWithTolerance(actual, expected, fractionDigits = PRECISION) {\n    const roundedActual = roundTo(actual, fractionDigits);\n    const roundedExpected = roundTo(expected, fractionDigits);\n    return Math.sign(roundedActual - roundedExpected);\n}\n/**\n * Compares two arrays for equality.\n */\nexport function areArraysEqual(arrA, arrB) {\n    if (arrA.length !== arrB.length)\n        return false;\n    for (let index = 0; index < arrA.length; index++) {\n        if (arrA[index] !== arrB[index])\n            return false;\n    }\n    return true;\n}\n/**\n * Rounds a number to a given number of decimal places.\n */\nfunction roundTo(value, decimals) {\n    return parseFloat(value.toFixed(decimals));\n}\n","export function assert(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexpectedCondition, message = \"Assertion failed!\") {\n    if (!expectedCondition) {\n        // eslint-disable-next-line no-console\n        console.error(message);\n        throw Error(message);\n    }\n}\n","import { PRECISION } from \"../constants.js\";\nimport { assert } from \"./assert.js\";\nimport { compareNumbersWithTolerance } from \"./compare.js\";\n/**\n * Resizes a pane based on its constraints.\n */\nexport function resizePane({ paneConstraints: paneConstraintsArray, paneIndex, initialSize, }) {\n    const paneConstraints = paneConstraintsArray[paneIndex];\n    assert(paneConstraints != null, \"Pane constraints should not be null.\");\n    const { collapsedSize = 0, collapsible, maxSize = 100, minSize = 0 } = paneConstraints;\n    let newSize = initialSize;\n    if (compareNumbersWithTolerance(newSize, minSize) < 0) {\n        newSize = getAdjustedSizeForCollapsible(newSize, collapsible, collapsedSize, minSize);\n    }\n    newSize = Math.min(maxSize, newSize);\n    return parseFloat(newSize.toFixed(PRECISION));\n}\n/**\n * Adjusts the size of a pane based on its collapsible state.\n *\n * If the pane is collapsible, the size will be snapped to the collapsed size\n * or the minimum size based on the halfway point.\n */\nfunction getAdjustedSizeForCollapsible(size, collapsible, collapsedSize, minSize) {\n    if (!collapsible)\n        return minSize;\n    // Snap collapsible panes closed or open based on the halfway point.\n    const halfwayPoint = (collapsedSize + minSize) / 2;\n    return compareNumbersWithTolerance(size, halfwayPoint) < 0 ? collapsedSize : minSize;\n}\n","import { assert } from \"./assert.js\";\nimport { compareNumbersWithTolerance, areNumbersAlmostEqual, resizePane, } from \"./index.js\";\n/**\n * Adjusts the layout of panes based on the delta of the resize handle.\n * All units must be in percentages; pixel values should be pre-converted.\n *\n * Credit: https://github.com/bvaughn/react-resizable-panels\n */\nexport function adjustLayoutByDelta({ delta, layout: prevLayout, paneConstraints: paneConstraintsArray, pivotIndices, trigger, }) {\n    if (areNumbersAlmostEqual(delta, 0))\n        return prevLayout;\n    const nextLayout = [...prevLayout];\n    const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n    let deltaApplied = 0;\n    // A resizing pane affects the panes before or after it.\n    //\n    // A negative delta means the pane(s) immediately after the resize handle should grow/expand by decreasing its offset.\n    // Other panes may also need to shrink/contract (and shift) to make room, depending on the min weights.\n    //\n    // A positive delta means the pane(s) immediately before the resize handle should \"expand\".\n    // This is accomplished by shrinking/contracting (and shifting) one or more of the panes after the resize handle.\n    {\n        // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\n        // We no longer check the halfway threshold because this may prevent the pane from expanding at all.\n        if (trigger === \"keyboard\") {\n            {\n                // Check if we should expand a collapsed pane\n                const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n                const paneConstraints = paneConstraintsArray[index];\n                assert(paneConstraints);\n                if (paneConstraints.collapsible) {\n                    const prevSize = prevLayout[index];\n                    assert(prevSize != null);\n                    const paneConstraints = paneConstraintsArray[index];\n                    assert(paneConstraints);\n                    const { collapsedSize = 0, minSize = 0 } = paneConstraints;\n                    if (areNumbersAlmostEqual(prevSize, collapsedSize)) {\n                        const localDelta = minSize - prevSize;\n                        //DEBUG.push(`  -> expand delta: ${localDelta}`);\n                        if (compareNumbersWithTolerance(localDelta, Math.abs(delta)) > 0) {\n                            delta = delta < 0 ? 0 - localDelta : localDelta;\n                            //DEBUG.push(`  -> delta: ${delta}`);\n                        }\n                    }\n                }\n            }\n            {\n                // Check if we should collapse a pane at its minimum size\n                const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n                const paneConstraints = paneConstraintsArray[index];\n                assert(paneConstraints);\n                const { collapsible } = paneConstraints;\n                if (collapsible) {\n                    const prevSize = prevLayout[index];\n                    assert(prevSize != null);\n                    const paneConstraints = paneConstraintsArray[index];\n                    assert(paneConstraints);\n                    const { collapsedSize = 0, minSize = 0 } = paneConstraints;\n                    if (areNumbersAlmostEqual(prevSize, minSize)) {\n                        const localDelta = prevSize - collapsedSize;\n                        if (compareNumbersWithTolerance(localDelta, Math.abs(delta)) > 0) {\n                            delta = delta < 0 ? 0 - localDelta : localDelta;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    {\n        // Pre-calculate max available delta in the opposite direction of our pivot.\n        // This will be the maximum amount we're allowed to expand/contract the panes in the primary direction.\n        // If this amount is less than the requested delta, adjust the requested delta.\n        // If this amount is greater than the requested delta, that's useful information tooâ€“\n        // as an expanding pane might change from collapsed to min size.\n        const increment = delta < 0 ? 1 : -1;\n        let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        let maxAvailableDelta = 0;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const prevSize = prevLayout[index];\n            assert(prevSize != null);\n            const maxSafeSize = resizePane({\n                paneConstraints: paneConstraintsArray,\n                paneIndex: index,\n                initialSize: 100,\n            });\n            const delta = maxSafeSize - prevSize;\n            maxAvailableDelta += delta;\n            index += increment;\n            if (index < 0 || index >= paneConstraintsArray.length) {\n                break;\n            }\n        }\n        const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n        delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n    }\n    {\n        // Delta added to a pane needs to be subtracted from other panes (within the constraints that those panes allow).\n        const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        let index = pivotIndex;\n        while (index >= 0 && index < paneConstraintsArray.length) {\n            const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n            const prevSize = prevLayout[index];\n            assert(prevSize != null);\n            const unsafeSize = prevSize - deltaRemaining;\n            const safeSize = resizePane({\n                paneConstraints: paneConstraintsArray,\n                paneIndex: index,\n                initialSize: unsafeSize,\n            });\n            if (!areNumbersAlmostEqual(prevSize, safeSize)) {\n                deltaApplied += prevSize - safeSize;\n                nextLayout[index] = safeSize;\n                if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), undefined, {\n                    numeric: true,\n                }) >= 0) {\n                    break;\n                }\n            }\n            if (delta < 0) {\n                index--;\n            }\n            else {\n                index++;\n            }\n        }\n    }\n    // If we were unable to resize any of the panes, return the previous state.\n    // This will essentially bailout and ignore e.g. drags past a pane's boundaries\n    if (areNumbersAlmostEqual(deltaApplied, 0)) {\n        return prevLayout;\n    }\n    {\n        // Now distribute the applied delta to the panes in the other direction\n        const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const prevSize = prevLayout[pivotIndex];\n        assert(prevSize != null);\n        const unsafeSize = prevSize + deltaApplied;\n        const safeSize = resizePane({\n            paneConstraints: paneConstraintsArray,\n            paneIndex: pivotIndex,\n            initialSize: unsafeSize,\n        });\n        // Adjust the pivot pane before, but only by the amount that surrounding panes were able to shrink/contract.\n        nextLayout[pivotIndex] = safeSize;\n        // Edge case where expanding or contracting one pane caused another one to change collapsed state\n        if (!areNumbersAlmostEqual(safeSize, unsafeSize)) {\n            let deltaRemaining = unsafeSize - safeSize;\n            const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n            let index = pivotIndex;\n            while (index >= 0 && index < paneConstraintsArray.length) {\n                const prevSize = nextLayout[index];\n                assert(prevSize != null);\n                const unsafeSize = prevSize + deltaRemaining;\n                const safeSize = resizePane({\n                    paneConstraints: paneConstraintsArray,\n                    paneIndex: index,\n                    initialSize: unsafeSize,\n                });\n                if (!areNumbersAlmostEqual(prevSize, safeSize)) {\n                    deltaRemaining -= safeSize - prevSize;\n                    nextLayout[index] = safeSize;\n                }\n                if (areNumbersAlmostEqual(deltaRemaining, 0))\n                    break;\n                delta > 0 ? index-- : index++;\n            }\n        }\n    }\n    const totalSize = nextLayout.reduce((total, size) => size + total, 0);\n    if (!areNumbersAlmostEqual(totalSize, 100))\n        return prevLayout;\n    return nextLayout;\n}\n","export const isBrowser = typeof document !== \"undefined\";\nexport function isHTMLElement(element) {\n    return element instanceof HTMLElement;\n}\nexport function isKeyDown(event) {\n    return event.type === \"keydown\";\n}\nexport function isMouseEvent(event) {\n    return event.type.startsWith(\"mouse\");\n}\nexport function isTouchEvent(event) {\n    return event.type.startsWith(\"touch\");\n}\n","import { initializeStorage, loadPaneGroupState, resizePane, resetGlobalCursorStyle, setGlobalCursorStyle, updateStorageValues, adjustLayoutByDelta, areNumbersAlmostEqual, areArraysEqual, generateId, removeUndefined, clientEffect, toWritableStores, calculateAriaValues, addEventListener, computePaneFlexBoxStyle, styleToString, isBrowser, isHTMLElement, isKeyDown, isMouseEvent, isTouchEvent, } from \"./utils/index.js\";\nimport { derived, get, writable } from \"svelte/store\";\nimport { assert } from \"./utils/assert.js\";\nimport { onMount } from \"svelte\";\nexport const defaultStorage = {\n    getItem: (name) => {\n        initializeStorage(defaultStorage);\n        return defaultStorage.getItem(name);\n    },\n    setItem: (name, value) => {\n        initializeStorage(defaultStorage);\n        defaultStorage.setItem(name, value);\n    },\n};\nconst defaultProps = {\n    id: null,\n    onLayout: null,\n    keyboardResizeBy: null,\n    autoSaveId: null,\n    direction: \"horizontal\",\n    storage: defaultStorage,\n};\nexport function createPaneForge(props) {\n    const withDefaults = {\n        ...defaultProps,\n        ...removeUndefined(props),\n    };\n    const options = toWritableStores(withDefaults);\n    const { autoSaveId, direction, keyboardResizeBy, storage, onLayout } = options;\n    const groupId = writable(generateId());\n    const dragState = writable(null);\n    const layout = writable([]);\n    const paneDataArray = writable([]);\n    const paneDataArrayChanged = writable(false);\n    const paneIdToLastNotifiedSizeMap = writable({});\n    const paneSizeBeforeCollapseMap = writable(new Map());\n    const prevDelta = writable(0);\n    clientEffect([groupId, layout, paneDataArray], ([$groupId, $layout, $paneDataArray]) => {\n        const unsub = updateResizeHandleAriaValues({\n            groupId: $groupId,\n            layout: $layout,\n            paneDataArray: $paneDataArray,\n        });\n        return unsub;\n    });\n    onMount(() => {\n        const unsub = setResizeHandlerEventListeners();\n        return unsub;\n    });\n    clientEffect([autoSaveId, layout, storage], ([$autoSaveId, $layout, $storage]) => {\n        if (!$autoSaveId)\n            return;\n        updateStorageValues({\n            autoSaveId: $autoSaveId,\n            layout: $layout,\n            storage: $storage,\n            paneDataArrayStore: paneDataArray,\n            paneSizeBeforeCollapseStore: paneSizeBeforeCollapseMap,\n        });\n    });\n    function collapsePane(paneData) {\n        const $prevLayout = get(layout);\n        const $paneDataArray = get(paneDataArray);\n        if (!paneData.constraints.collapsible)\n            return;\n        const paneConstraintsArray = $paneDataArray.map((paneData) => paneData.constraints);\n        const { collapsedSize = 0, paneSize, pivotIndices, } = paneDataHelper($paneDataArray, paneData, $prevLayout);\n        assert(paneSize != null);\n        if (paneSize === collapsedSize)\n            return;\n        // Store the size before collapse, which is returned when `expand()` is called\n        paneSizeBeforeCollapseMap.update((curr) => {\n            curr.set(paneData.id, paneSize);\n            return curr;\n        });\n        const isLastPane = findPaneDataIndex($paneDataArray, paneData) === $paneDataArray.length - 1;\n        const delta = isLastPane ? paneSize - collapsedSize : collapsedSize - paneSize;\n        const nextLayout = adjustLayoutByDelta({\n            delta,\n            layout: $prevLayout,\n            paneConstraints: paneConstraintsArray,\n            pivotIndices,\n            trigger: \"imperative-api\",\n        });\n        if (areArraysEqual($prevLayout, nextLayout))\n            return;\n        layout.set(nextLayout);\n        const $onLayout = get(onLayout);\n        if ($onLayout) {\n            $onLayout(nextLayout);\n        }\n        callPaneCallbacks($paneDataArray, nextLayout, get(paneIdToLastNotifiedSizeMap));\n    }\n    function getPaneSize(paneData) {\n        const $layout = get(layout);\n        const $paneDataArray = get(paneDataArray);\n        const { paneSize } = paneDataHelper($paneDataArray, paneData, $layout);\n        return paneSize;\n    }\n    const getPaneStyle = derived([paneDataArray, layout, dragState], ([$paneDataArray, $layout, $dragState]) => {\n        return (paneData, defaultSize) => {\n            const paneIndex = findPaneDataIndex($paneDataArray, paneData);\n            return computePaneFlexBoxStyle({\n                defaultSize,\n                dragState: $dragState,\n                layout: $layout,\n                paneData: $paneDataArray,\n                paneIndex,\n            });\n        };\n    });\n    function isPaneExpanded(paneData) {\n        const $paneDataArray = get(paneDataArray);\n        const $layout = get(layout);\n        const { collapsedSize = 0, collapsible, paneSize, } = paneDataHelper($paneDataArray, paneData, $layout);\n        return !collapsible || paneSize > collapsedSize;\n    }\n    function registerPane(paneData) {\n        paneDataArray.update((curr) => {\n            const newArr = [...curr, paneData];\n            newArr.sort((paneA, paneB) => {\n                const orderA = paneA.order;\n                const orderB = paneB.order;\n                if (orderA == null && orderB == null) {\n                    return 0;\n                }\n                else if (orderA == null) {\n                    return -1;\n                }\n                else if (orderB == null) {\n                    return 1;\n                }\n                else {\n                    return orderA - orderB;\n                }\n            });\n            return newArr;\n        });\n        paneDataArrayChanged.set(true);\n    }\n    clientEffect([paneDataArrayChanged], ([$paneDataArrayChanged]) => {\n        if (!$paneDataArrayChanged)\n            return;\n        paneDataArrayChanged.set(false);\n        const $autoSaveId = get(autoSaveId);\n        const $storage = get(storage);\n        const $prevLayout = get(layout);\n        const $paneDataArray = get(paneDataArray);\n        // If this pane has been configured to persist sizing information,\n        // default size should be restored from local storage if possible.\n        let unsafeLayout = null;\n        if ($autoSaveId) {\n            const state = loadPaneGroupState($autoSaveId, $paneDataArray, $storage);\n            if (state) {\n                paneSizeBeforeCollapseMap.set(new Map(Object.entries(state.expandToSizes)));\n                unsafeLayout = state.layout;\n            }\n        }\n        if (unsafeLayout == null) {\n            unsafeLayout = getUnsafeDefaultLayout({\n                paneDataArray: $paneDataArray,\n            });\n        }\n        // Validate even saved layouts in case something has changed since last render\n        const nextLayout = validatePaneGroupLayout({\n            layout: unsafeLayout,\n            paneConstraints: $paneDataArray.map((paneData) => paneData.constraints),\n        });\n        if (areArraysEqual($prevLayout, nextLayout))\n            return;\n        layout.set(nextLayout);\n        const $onLayout = get(onLayout);\n        if ($onLayout) {\n            $onLayout(nextLayout);\n        }\n        callPaneCallbacks($paneDataArray, nextLayout, get(paneIdToLastNotifiedSizeMap));\n    });\n    function registerResizeHandle(dragHandleId) {\n        return function resizeHandler(event) {\n            event.preventDefault();\n            const $direction = get(direction);\n            const $dragState = get(dragState);\n            const $groupId = get(groupId);\n            const $keyboardResizeBy = get(keyboardResizeBy);\n            const $prevLayout = get(layout);\n            const $paneDataArray = get(paneDataArray);\n            const { initialLayout } = $dragState ?? {};\n            const pivotIndices = getPivotIndices($groupId, dragHandleId);\n            let delta = getDeltaPercentage(event, dragHandleId, $direction, $dragState, $keyboardResizeBy);\n            if (delta === 0)\n                return;\n            // support RTL\n            const isHorizontal = $direction === \"horizontal\";\n            if (document.dir === \"rtl\" && isHorizontal) {\n                delta = -delta;\n            }\n            const paneConstraints = $paneDataArray.map((paneData) => paneData.constraints);\n            const nextLayout = adjustLayoutByDelta({\n                delta,\n                layout: initialLayout ?? $prevLayout,\n                paneConstraints: paneConstraints,\n                pivotIndices,\n                trigger: isKeyDown(event) ? \"keyboard\" : \"mouse-or-touch\",\n            });\n            const layoutChanged = !areArraysEqual($prevLayout, nextLayout);\n            // Only update the cursor for layout changes triggered by touch/mouse events (not keyboard)\n            // Update the cursor even if the layout hasn't changed (we may need to show an invalid cursor state)\n            if (isMouseEvent(event) || isTouchEvent(event)) {\n                // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n                // In this case, Pane sizes might not changeâ€“\n                // but updating cursor in this scenario would cause a flicker.\n                const $prevDelta = get(prevDelta);\n                if ($prevDelta != delta) {\n                    prevDelta.set(delta);\n                    if (!layoutChanged) {\n                        // If the pointer has moved too far to resize the pane any further,\n                        // update the cursor style for a visual clue.\n                        // This mimics VS Code behavior.\n                        if (isHorizontal) {\n                            setGlobalCursorStyle(delta < 0 ? \"horizontal-min\" : \"horizontal-max\");\n                        }\n                        else {\n                            setGlobalCursorStyle(delta < 0 ? \"vertical-min\" : \"vertical-max\");\n                        }\n                    }\n                    else {\n                        setGlobalCursorStyle(isHorizontal ? \"horizontal\" : \"vertical\");\n                    }\n                }\n            }\n            if (layoutChanged) {\n                layout.set(nextLayout);\n                const $onLayout = get(onLayout);\n                if ($onLayout) {\n                    $onLayout(nextLayout);\n                }\n                callPaneCallbacks($paneDataArray, nextLayout, get(paneIdToLastNotifiedSizeMap));\n            }\n        };\n    }\n    function resizePane(paneData, unsafePaneSize) {\n        const $prevLayout = get(layout);\n        const $paneDataArray = get(paneDataArray);\n        const paneConstraintsArr = $paneDataArray.map((paneData) => paneData.constraints);\n        const { paneSize, pivotIndices } = paneDataHelper($paneDataArray, paneData, $prevLayout);\n        assert(paneSize != null);\n        const isLastPane = findPaneDataIndex($paneDataArray, paneData) === $paneDataArray.length - 1;\n        const delta = isLastPane ? paneSize - unsafePaneSize : unsafePaneSize - paneSize;\n        const nextLayout = adjustLayoutByDelta({\n            delta,\n            layout: $prevLayout,\n            paneConstraints: paneConstraintsArr,\n            pivotIndices,\n            trigger: \"imperative-api\",\n        });\n        if (areArraysEqual($prevLayout, nextLayout))\n            return;\n        layout.set(nextLayout);\n        const $onLayout = get(onLayout);\n        $onLayout?.(nextLayout);\n        callPaneCallbacks($paneDataArray, nextLayout, get(paneIdToLastNotifiedSizeMap));\n    }\n    function startDragging(dragHandleId, event) {\n        const $direction = get(direction);\n        const $layout = get(layout);\n        const handleElement = getResizeHandleElement(dragHandleId);\n        assert(handleElement);\n        const initialCursorPosition = getResizeEventCursorPosition($direction, event);\n        dragState.set({\n            dragHandleId,\n            dragHandleRect: handleElement.getBoundingClientRect(),\n            initialCursorPosition,\n            initialLayout: $layout,\n        });\n    }\n    function stopDragging() {\n        resetGlobalCursorStyle();\n        dragState.set(null);\n    }\n    function unregisterPane(paneData) {\n        const $paneDataArray = get(paneDataArray);\n        const index = findPaneDataIndex($paneDataArray, paneData);\n        if (index < 0)\n            return;\n        paneDataArray.update((curr) => {\n            curr.splice(index, 1);\n            paneIdToLastNotifiedSizeMap.update((curr) => {\n                delete curr[paneData.id];\n                return curr;\n            });\n            paneDataArrayChanged.set(true);\n            return curr;\n        });\n    }\n    function isPaneCollapsed(paneData) {\n        const $paneDataArray = get(paneDataArray);\n        const $layout = get(layout);\n        const { collapsedSize = 0, collapsible, paneSize, } = paneDataHelper($paneDataArray, paneData, $layout);\n        return collapsible === true && paneSize === collapsedSize;\n    }\n    function expandPane(paneData) {\n        const $prevLayout = get(layout);\n        const $paneDataArray = get(paneDataArray);\n        if (!paneData.constraints.collapsible)\n            return;\n        const paneConstraintsArray = $paneDataArray.map((paneData) => paneData.constraints);\n        const { collapsedSize = 0, paneSize, minSize = 0, pivotIndices, } = paneDataHelper($paneDataArray, paneData, $prevLayout);\n        if (paneSize !== collapsedSize)\n            return;\n        // Restore this pane to the size it was before it was collapsed, if possible.\n        const prevPaneSize = get(paneSizeBeforeCollapseMap).get(paneData.id);\n        const baseSize = prevPaneSize != null && prevPaneSize >= minSize ? prevPaneSize : minSize;\n        const isLastPane = findPaneDataIndex($paneDataArray, paneData) === $paneDataArray.length - 1;\n        const delta = isLastPane ? paneSize - baseSize : baseSize - paneSize;\n        const nextLayout = adjustLayoutByDelta({\n            delta,\n            layout: $prevLayout,\n            paneConstraints: paneConstraintsArray,\n            pivotIndices,\n            trigger: \"imperative-api\",\n        });\n        if (areArraysEqual($prevLayout, nextLayout))\n            return;\n        layout.set(nextLayout);\n        const $onLayout = get(onLayout);\n        $onLayout?.(nextLayout);\n        callPaneCallbacks($paneDataArray, nextLayout, get(paneIdToLastNotifiedSizeMap));\n    }\n    const paneGroupStyle = derived([direction], ([$direction]) => {\n        return styleToString({\n            display: \"flex\",\n            \"flex-direction\": $direction === \"horizontal\" ? \"row\" : \"column\",\n            height: \"100%\",\n            overflow: \"hidden\",\n            width: \"100%\",\n        });\n    });\n    const paneGroupSelectors = derived([direction, groupId], ([$direction, $groupId]) => {\n        return {\n            \"data-pane-group\": \"\",\n            \"data-direction\": $direction,\n            \"data-pane-group-id\": $groupId,\n        };\n    });\n    const paneGroupAttrs = derived([paneGroupStyle, paneGroupSelectors], ([$style, $selectors]) => {\n        return {\n            style: $style,\n            ...$selectors,\n        };\n    });\n    function setResizeHandlerEventListeners() {\n        const $groupId = get(groupId);\n        const handles = getResizeHandleElementsForGroup($groupId);\n        const unsubHandlers = handles.map((handle) => {\n            const handleId = handle.getAttribute(\"data-pane-resizer-id\");\n            if (!handleId)\n                return noop;\n            const [idBefore, idAfter] = getResizeHandlePaneIds($groupId, handleId, get(paneDataArray));\n            if (idBefore == null || idAfter == null)\n                return noop;\n            const onKeydown = (e) => {\n                if (e.defaultPrevented || e.key !== \"Enter\")\n                    return;\n                e.preventDefault();\n                const $paneDataArray = get(paneDataArray);\n                const index = $paneDataArray.findIndex((paneData) => paneData.id === idBefore);\n                if (index < 0)\n                    return;\n                const paneData = $paneDataArray[index];\n                assert(paneData);\n                const $layout = get(layout);\n                const size = $layout[index];\n                const { collapsedSize = 0, collapsible, minSize = 0 } = paneData.constraints;\n                if (!(size != null && collapsible))\n                    return;\n                const nextLayout = adjustLayoutByDelta({\n                    delta: areNumbersAlmostEqual(size, collapsedSize) ? minSize - size : collapsedSize - size,\n                    layout: $layout,\n                    paneConstraints: $paneDataArray.map((paneData) => paneData.constraints),\n                    pivotIndices: getPivotIndices($groupId, handleId),\n                    trigger: \"keyboard\",\n                });\n                if ($layout !== nextLayout) {\n                    layout.set(nextLayout);\n                }\n            };\n            const unsubListener = addEventListener(handle, \"keydown\", onKeydown);\n            return () => {\n                unsubListener();\n            };\n        });\n        return () => {\n            unsubHandlers.forEach((unsub) => unsub());\n        };\n    }\n    function setLayout(newLayout) {\n        layout.set(newLayout);\n    }\n    function getLayout() {\n        return get(layout);\n    }\n    return {\n        methods: {\n            collapsePane,\n            expandPane,\n            getSize: getPaneSize,\n            getPaneStyle,\n            isCollapsed: isPaneCollapsed,\n            isExpanded: isPaneExpanded,\n            registerPane,\n            registerResizeHandle,\n            resizePane,\n            startDragging,\n            stopDragging,\n            unregisterPane,\n            setLayout,\n            getLayout,\n        },\n        states: {\n            direction,\n            dragState,\n            groupId,\n            paneGroupAttrs,\n            paneGroupSelectors,\n            paneGroupStyle,\n            layout,\n        },\n        options,\n    };\n}\nfunction updateResizeHandleAriaValues({ groupId, layout, paneDataArray, }) {\n    const resizeHandleElements = getResizeHandleElementsForGroup(groupId);\n    for (let index = 0; index < paneDataArray.length - 1; index++) {\n        const { valueMax, valueMin, valueNow } = calculateAriaValues({\n            layout,\n            panesArray: paneDataArray,\n            pivotIndices: [index, index + 1],\n        });\n        const resizeHandleEl = resizeHandleElements[index];\n        if (isHTMLElement(resizeHandleEl)) {\n            const paneData = paneDataArray[index];\n            resizeHandleEl.setAttribute(\"aria-controls\", paneData.id);\n            resizeHandleEl.setAttribute(\"aria-valuemax\", \"\" + Math.round(valueMax));\n            resizeHandleEl.setAttribute(\"aria-valuemin\", \"\" + Math.round(valueMin));\n            resizeHandleEl.setAttribute(\"aria-valuenow\", valueNow != null ? \"\" + Math.round(valueNow) : \"\");\n        }\n    }\n    return () => {\n        resizeHandleElements.forEach((resizeHandleElement) => {\n            resizeHandleElement.removeAttribute(\"aria-controls\");\n            resizeHandleElement.removeAttribute(\"aria-valuemax\");\n            resizeHandleElement.removeAttribute(\"aria-valuemin\");\n            resizeHandleElement.removeAttribute(\"aria-valuenow\");\n        });\n    };\n}\nexport function getResizeHandleElementsForGroup(groupId) {\n    if (!isBrowser)\n        return [];\n    return Array.from(document.querySelectorAll(`[data-pane-resizer-id][data-pane-group-id=\"${groupId}\"]`));\n}\nfunction getPaneGroupElement(id) {\n    if (!isBrowser)\n        return null;\n    const element = document.querySelector(`[data-pane-group][data-pane-group-id=\"${id}\"]`);\n    if (element) {\n        return element;\n    }\n    return null;\n}\nfunction noop() {\n    // do nothing\n}\nexport function getResizeHandlePaneIds(groupId, handleId, panesArray) {\n    const handle = getResizeHandleElement(handleId);\n    const handles = getResizeHandleElementsForGroup(groupId);\n    const index = handle ? handles.indexOf(handle) : -1;\n    const idBefore = panesArray[index]?.id ?? null;\n    const idAfter = panesArray[index + 1]?.id ?? null;\n    return [idBefore, idAfter];\n}\nexport function getResizeHandleElement(id) {\n    if (!isBrowser)\n        return null;\n    const element = document.querySelector(`[data-pane-resizer-id=\"${id}\"]`);\n    if (element) {\n        return element;\n    }\n    return null;\n}\nexport function getResizeHandleElementIndex(groupId, id) {\n    if (!isBrowser)\n        return null;\n    const handles = getResizeHandleElementsForGroup(groupId);\n    const index = handles.findIndex((handle) => handle.getAttribute(\"data-pane-resizer-id\") === id);\n    return index ?? null;\n}\nfunction getPivotIndices(groupId, dragHandleId) {\n    const index = getResizeHandleElementIndex(groupId, dragHandleId);\n    return index != null ? [index, index + 1] : [-1, -1];\n}\nfunction paneDataHelper(paneDataArray, paneData, layout) {\n    const paneConstraintsArray = paneDataArray.map((paneData) => paneData.constraints);\n    const paneIndex = findPaneDataIndex(paneDataArray, paneData);\n    const paneConstraints = paneConstraintsArray[paneIndex];\n    const isLastPane = paneIndex === paneDataArray.length - 1;\n    const pivotIndices = isLastPane ? [paneIndex - 1, paneIndex] : [paneIndex, paneIndex + 1];\n    const paneSize = layout[paneIndex];\n    return {\n        ...paneConstraints,\n        paneSize,\n        pivotIndices,\n    };\n}\nfunction findPaneDataIndex(paneDataArray, paneData) {\n    return paneDataArray.findIndex((prevPaneData) => prevPaneData.id === paneData.id);\n}\n// Layout should be pre-converted into percentages\nfunction callPaneCallbacks(paneArray, layout, paneIdToLastNotifiedSizeMap) {\n    layout.forEach((size, index) => {\n        const paneData = paneArray[index];\n        assert(paneData);\n        const { callbacks, constraints, id: paneId } = paneData;\n        const { collapsedSize = 0, collapsible } = constraints;\n        const lastNotifiedSize = paneIdToLastNotifiedSizeMap[paneId];\n        // invert the logic from below\n        if (!(lastNotifiedSize == null || size !== lastNotifiedSize))\n            return;\n        paneIdToLastNotifiedSizeMap[paneId] = size;\n        const { onCollapse, onExpand, onResize } = callbacks;\n        onResize?.(size, lastNotifiedSize);\n        if (collapsible && (onCollapse || onExpand)) {\n            if (onExpand &&\n                (lastNotifiedSize == null || lastNotifiedSize === collapsedSize) &&\n                size !== collapsedSize) {\n                onExpand();\n            }\n            if (onCollapse &&\n                (lastNotifiedSize == null || lastNotifiedSize !== collapsedSize) &&\n                size === collapsedSize) {\n                onCollapse();\n            }\n        }\n    });\n}\nfunction getUnsafeDefaultLayout({ paneDataArray }) {\n    const layout = Array(paneDataArray.length);\n    const paneConstraintsArray = paneDataArray.map((paneData) => paneData.constraints);\n    let numPanesWithSizes = 0;\n    let remainingSize = 100;\n    // Distribute default sizes first\n    for (let index = 0; index < paneDataArray.length; index++) {\n        const paneConstraints = paneConstraintsArray[index];\n        assert(paneConstraints);\n        const { defaultSize } = paneConstraints;\n        if (defaultSize != null) {\n            numPanesWithSizes++;\n            layout[index] = defaultSize;\n            remainingSize -= defaultSize;\n        }\n    }\n    // Remaining size should be distributed evenly between panes without default sizes\n    for (let index = 0; index < paneDataArray.length; index++) {\n        const paneConstraints = paneConstraintsArray[index];\n        assert(paneConstraints);\n        const { defaultSize } = paneConstraints;\n        if (defaultSize != null) {\n            continue;\n        }\n        const numRemainingPanes = paneDataArray.length - numPanesWithSizes;\n        const size = remainingSize / numRemainingPanes;\n        numPanesWithSizes++;\n        layout[index] = size;\n        remainingSize -= size;\n    }\n    return layout;\n}\n// All units must be in percentages\nfunction validatePaneGroupLayout({ layout: prevLayout, paneConstraints, }) {\n    const nextLayout = [...prevLayout];\n    const nextLayoutTotalSize = nextLayout.reduce((accumulated, current) => accumulated + current, 0);\n    // Validate layout expectations\n    if (nextLayout.length !== paneConstraints.length) {\n        throw Error(`Invalid ${paneConstraints.length} pane layout: ${nextLayout\n            .map((size) => `${size}%`)\n            .join(\", \")}`);\n    }\n    else if (!areNumbersAlmostEqual(nextLayoutTotalSize, 100)) {\n        for (let index = 0; index < paneConstraints.length; index++) {\n            const unsafeSize = nextLayout[index];\n            assert(unsafeSize != null);\n            const safeSize = (100 / nextLayoutTotalSize) * unsafeSize;\n            nextLayout[index] = safeSize;\n        }\n    }\n    let remainingSize = 0;\n    // First pass: Validate the proposed layout given each pane's constraints\n    for (let index = 0; index < paneConstraints.length; index++) {\n        const unsafeSize = nextLayout[index];\n        assert(unsafeSize != null);\n        const safeSize = resizePane({\n            paneConstraints,\n            paneIndex: index,\n            initialSize: unsafeSize,\n        });\n        if (unsafeSize != safeSize) {\n            remainingSize += unsafeSize - safeSize;\n            nextLayout[index] = safeSize;\n        }\n    }\n    // If there is additional, left over space, assign it to any pane(s) that permits it\n    // (It's not worth taking multiple additional passes to evenly distribute)\n    if (!areNumbersAlmostEqual(remainingSize, 0)) {\n        for (let index = 0; index < paneConstraints.length; index++) {\n            const prevSize = nextLayout[index];\n            assert(prevSize != null);\n            const unsafeSize = prevSize + remainingSize;\n            const safeSize = resizePane({\n                paneConstraints,\n                paneIndex: index,\n                initialSize: unsafeSize,\n            });\n            if (prevSize !== safeSize) {\n                remainingSize -= safeSize - prevSize;\n                nextLayout[index] = safeSize;\n                // Once we've used up the remainder, bail\n                if (areNumbersAlmostEqual(remainingSize, 0)) {\n                    break;\n                }\n            }\n        }\n    }\n    return nextLayout;\n}\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nfunction getDeltaPercentage(e, dragHandleId, dir, initialDragState, keyboardResizeBy) {\n    if (isKeyDown(e)) {\n        const isHorizontal = dir === \"horizontal\";\n        let delta = 0;\n        if (e.shiftKey) {\n            delta = 100;\n        }\n        else if (keyboardResizeBy != null) {\n            delta = keyboardResizeBy;\n        }\n        else {\n            delta = 10;\n        }\n        let movement = 0;\n        switch (e.key) {\n            case \"ArrowDown\":\n                movement = isHorizontal ? 0 : delta;\n                break;\n            case \"ArrowLeft\":\n                movement = isHorizontal ? -delta : 0;\n                break;\n            case \"ArrowRight\":\n                movement = isHorizontal ? delta : 0;\n                break;\n            case \"ArrowUp\":\n                movement = isHorizontal ? 0 : -delta;\n                break;\n            case \"End\":\n                movement = 100;\n                break;\n            case \"Home\":\n                movement = -100;\n                break;\n        }\n        return movement;\n    }\n    else {\n        if (initialDragState == null)\n            return 0;\n        return getDragOffsetPercentage(e, dragHandleId, dir, initialDragState);\n    }\n}\nfunction getDragOffsetPercentage(e, dragHandleId, dir, initialDragState) {\n    const isHorizontal = dir === \"horizontal\";\n    const handleElement = getResizeHandleElement(dragHandleId);\n    assert(handleElement);\n    const groupId = handleElement.getAttribute(\"data-pane-group-id\");\n    assert(groupId);\n    const { initialCursorPosition } = initialDragState;\n    const cursorPosition = getResizeEventCursorPosition(dir, e);\n    const groupElement = getPaneGroupElement(groupId);\n    assert(groupElement);\n    const groupRect = groupElement.getBoundingClientRect();\n    const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;\n    const offsetPixels = cursorPosition - initialCursorPosition;\n    const offsetPercentage = (offsetPixels / groupSizeInPixels) * 100;\n    return offsetPercentage;\n}\nfunction getResizeEventCursorPosition(dir, e) {\n    const isHorizontal = dir === \"horizontal\";\n    if (isMouseEvent(e)) {\n        return isHorizontal ? e.clientX : e.clientY;\n    }\n    else if (isTouchEvent(e)) {\n        const firstTouch = e.touches[0];\n        assert(firstTouch);\n        return isHorizontal ? firstTouch.screenX : firstTouch.screenY;\n    }\n    else {\n        throw Error(`Unsupported event type \"${e.type}\"`);\n    }\n}\n","import { createPaneForge } from \"../internal/paneforge.js\";\nimport { getContext, hasContext, setContext } from \"svelte\";\nimport { removeUndefined, getOptionUpdater } from \"../internal/utils/index.js\";\nconst PF_GROUP_CTX = Symbol(\"PF_GROUP_CTX\");\nexport function setCtx(props) {\n    const paneForge = createPaneForge(removeUndefined(props));\n    const updateOption = getOptionUpdater(paneForge.options);\n    const ctxValue = { ...paneForge, updateOption };\n    setContext(PF_GROUP_CTX, ctxValue);\n    return ctxValue;\n}\nexport function getCtx(componentName) {\n    if (!hasContext(PF_GROUP_CTX)) {\n        throw new Error(`${componentName} components must be rendered with a <PaneGroup> container`);\n    }\n    return getContext(PF_GROUP_CTX);\n}\n","<script>import { setCtx } from \"./ctx.js\";\nimport {} from \"../internal/utils/index.js\";\nimport { defaultStorage } from \"../internal/paneforge.js\";\nexport let autoSaveId = null;\nexport let direction;\nexport let id = null;\nexport let keyboardResizeBy = null;\nexport let onLayoutChange = null;\nexport let storage = defaultStorage;\nexport let el = void 0;\nexport let paneGroup = void 0;\nlet styleFromProps = void 0;\nexport { styleFromProps as style };\nconst {\n  states: { paneGroupStyle, paneGroupSelectors, groupId },\n  methods: { setLayout, getLayout },\n  updateOption\n} = setCtx({\n  autoSaveId,\n  direction,\n  id,\n  keyboardResizeBy,\n  onLayout: onLayoutChange,\n  storage\n});\n$:\n  updateOption(\"autoSaveId\", autoSaveId);\n$:\n  updateOption(\"direction\", direction);\n$:\n  updateOption(\"id\", id);\n$:\n  updateOption(\"keyboardResizeBy\", keyboardResizeBy);\n$:\n  updateOption(\"onLayout\", onLayoutChange);\n$:\n  updateOption(\"storage\", storage);\npaneGroup = {\n  getLayout,\n  setLayout,\n  getId: () => $groupId\n};\n$:\n  style = $paneGroupStyle + (styleFromProps ?? \"\");\n</script>\n\n<div bind:this={el} id={$groupId} {...$paneGroupSelectors} {style} {...$$restProps}>\n\t<slot />\n</div>\n","<script>import { generateId } from \"../internal/utils/index.js\";\nimport { onMount } from \"svelte\";\nimport { getCtx } from \"./ctx.js\";\nexport let collapsedSize = void 0;\nexport let collapsible = void 0;\nexport let defaultSize = void 0;\nexport let maxSize = void 0;\nexport let minSize = void 0;\nexport let onCollapse = void 0;\nexport let onExpand = void 0;\nexport let onResize = void 0;\nexport let order = void 0;\nexport let el = void 0;\nexport let pane = void 0;\nlet idFromProps = void 0;\nexport { idFromProps as id };\nlet styleFromProps = void 0;\nexport { styleFromProps as style };\nconst {\n  methods: {\n    getPaneStyle,\n    registerPane,\n    unregisterPane,\n    collapsePane,\n    expandPane,\n    getSize,\n    isCollapsed,\n    isExpanded,\n    resizePane\n  },\n  states: { groupId }\n} = getCtx(\"Pane\");\nconst paneId = generateId(idFromProps);\nlet paneData;\n$:\n  paneData = {\n    callbacks: {\n      onCollapse,\n      onExpand,\n      onResize\n    },\n    constraints: {\n      collapsedSize,\n      collapsible,\n      defaultSize,\n      maxSize,\n      minSize\n    },\n    id: paneId,\n    idIsFromProps: idFromProps !== void 0,\n    order\n  };\npane = {\n  collapse: () => {\n    collapsePane(paneData);\n  },\n  expand: () => expandPane(paneData),\n  getSize: () => getSize(paneData),\n  isCollapsed: () => isCollapsed(paneData),\n  isExpanded: () => isExpanded(paneData),\n  resize: (size) => resizePane(paneData, size),\n  getId: () => paneId\n};\nonMount(() => {\n  registerPane(paneData);\n  return () => {\n    unregisterPane(paneData);\n  };\n});\n$:\n  style = $getPaneStyle(paneData, defaultSize) + (styleFromProps ?? \"\");\n$:\n  attrs = {\n    \"data-pane\": \"\",\n    \"data-pane-id\": paneId,\n    \"data-pane-group-id\": $groupId\n  };\n</script>\n\n<div bind:this={el} {style} {...attrs} {...$$restProps}>\n\t<slot />\n</div>\n","import { chain } from \"../internal/utils/chain.js\";\nimport { addEventListener } from \"../internal/utils/event.js\";\n/**\n * A Svelte action that adds resize handle functionality to an element.\n * This action is used to handle the dragging of a resize handle.\n */\nexport function resizeHandleAction(node, params) {\n    let unsub = () => { };\n    function update(params) {\n        unsub();\n        const { disabled, resizeHandler, isDragging, stopDragging, onDragging = undefined } = params;\n        if (disabled || resizeHandler === null || !isDragging)\n            return;\n        const onMove = (event) => {\n            resizeHandler(event);\n        };\n        const onMouseLeave = (event) => {\n            resizeHandler(event);\n        };\n        const stopDraggingAndBlur = () => {\n            node.blur();\n            stopDragging();\n            if (onDragging) {\n                onDragging(false);\n            }\n        };\n        unsub = chain(addEventListener(document.body, \"contextmenu\", stopDraggingAndBlur), addEventListener(document.body, \"mousemove\", onMove), addEventListener(document.body, \"touchmove\", onMove, { passive: false }), addEventListener(document.body, \"mouseleave\", onMouseLeave), addEventListener(window, \"mouseup\", stopDraggingAndBlur), addEventListener(window, \"touchend\", stopDraggingAndBlur));\n    }\n    update(params);\n    return {\n        update,\n        onDestroy() {\n            unsub();\n        },\n    };\n}\n","<script>import {\n  getResizeHandleElementIndex,\n  getResizeHandleElementsForGroup\n} from \"../internal/paneforge.js\";\nimport { generateId, getCursorStyle, styleToString } from \"../internal/utils/index.js\";\nimport { onMount } from \"svelte\";\nimport { getCtx } from \"./ctx.js\";\nimport { resizeHandleAction } from \"./pane-resizer.js\";\nexport let disabled = false;\nexport let onDraggingChange = void 0;\nexport let tabIndex = 0;\nexport let el = null;\nexport let idFromProps = void 0;\nexport { idFromProps as id };\nexport let styleFromProps = void 0;\nexport { styleFromProps as style };\nconst {\n  methods: { registerResizeHandle, startDragging, stopDragging },\n  states: { direction, dragState, groupId }\n} = getCtx(\"PaneResizer\");\nconst resizeHandleId = generateId(idFromProps);\n$:\n  isDragging = $dragState?.dragHandleId === resizeHandleId;\nlet isFocused = false;\nlet resizeHandler = null;\nfunction stopDraggingAndBlur() {\n  const element = el;\n  if (!element)\n    return;\n  element.blur();\n  stopDragging();\n  onDraggingChange?.(false);\n}\nonMount(() => {\n  if (disabled) {\n    resizeHandler = null;\n  } else {\n    resizeHandler = registerResizeHandle(resizeHandleId);\n  }\n});\n$:\n  if (disabled) {\n    resizeHandler = null;\n  } else {\n    resizeHandler = registerResizeHandle(resizeHandleId);\n  }\nfunction handleKeydown(event) {\n  if (disabled || !resizeHandler || event.defaultPrevented)\n    return;\n  const resizeKeys = [\"ArrowDown\", \"ArrowLeft\", \"ArrowRight\", \"ArrowUp\", \"End\", \"Home\"];\n  if (resizeKeys.includes(event.key)) {\n    event.preventDefault();\n    resizeHandler(event);\n    return;\n  }\n  if (event.key !== \"F6\")\n    return;\n  event.preventDefault();\n  const handles = getResizeHandleElementsForGroup($groupId);\n  const index = getResizeHandleElementIndex($groupId, resizeHandleId);\n  if (index === null)\n    return;\n  const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;\n  const nextHandle = handles[nextIndex];\n  nextHandle.focus();\n}\n$:\n  style = styleToString({\n    cursor: getCursorStyle($direction),\n    \"touch-action\": \"none\",\n    \"user-select\": \"none\",\n    \"-webkit-user-select\": \"none\",\n    \"-webkit-touch-callout\": \"none\"\n  }) + styleFromProps;\n$:\n  attrs = {\n    \"data-direction\": $direction,\n    \"data-pane-group-id\": $groupId,\n    \"data-active\": isDragging ? \"pointer\" : isFocused ? \"keyboard\" : void 0,\n    \"data-enabled\": !disabled,\n    \"data-pane-resizer-id\": resizeHandleId,\n    \"data-pane-resizer\": \"\"\n  };\n</script>\n\n<!-- svelte-ignore a11y-no-noninteractive-element-interactions -->\n<!-- eslint-disable-next-line svelte/valid-compile -->\n<!-- svelte-ignore a11y-no-noninteractive-tabindex -->\n<div\n\tbind:this={el}\n\trole=\"separator\"\n\t{style}\n\tuse:resizeHandleAction={{\n\t\tdisabled,\n\t\tresizeHandler,\n\t\tstopDragging,\n\t\tisDragging,\n\t\tonDragging: onDraggingChange,\n\t}}\n\ton:keydown={handleKeydown}\n\ton:blur={() => (isFocused = false)}\n\ton:focus={() => (isFocused = true)}\n\ton:mousedown={(e) => {\n\t\te.preventDefault();\n\t\tstartDragging(resizeHandleId, e);\n\t\tonDraggingChange?.(true);\n\t}}\n\ton:mouseup={stopDraggingAndBlur}\n\ton:touchcancel={stopDraggingAndBlur}\n\ton:touchend={stopDraggingAndBlur}\n\ton:touchstart={(e) => {\n\t\te.preventDefault();\n\t\tstartDragging(resizeHandleId, e);\n\t\tonDraggingChange?.(true);\n\t}}\n\ttabindex={tabIndex}\n\t{...attrs}\n\t{...$$restProps}\n>\n\t<slot />\n</div>\n","<script lang=\"ts\">\n\timport { onDestroy, onMount, createEventDispatcher } from 'svelte';\n\timport { flyAndScale } from '$lib/utils/transitions';\n\timport { fade, fly, slide } from 'svelte/transition';\n\n\tconst dispatch = createEventDispatcher();\n\n\texport let show = false;\n\texport let className = '';\n\n\tlet modalElement = null;\n\tlet mounted = false;\n\n\tconst handleKeyDown = (event: KeyboardEvent) => {\n\t\tif (event.key === 'Escape' && isTopModal()) {\n\t\t\tconsole.log('Escape');\n\t\t\tshow = false;\n\t\t}\n\t};\n\n\tconst isTopModal = () => {\n\t\tconst modals = document.getElementsByClassName('modal');\n\t\treturn modals.length && modals[modals.length - 1] === modalElement;\n\t};\n\n\tonMount(() => {\n\t\tmounted = true;\n\t});\n\n\t$: if (show && modalElement) {\n\t\tdocument.body.appendChild(modalElement);\n\t\twindow.addEventListener('keydown', handleKeyDown);\n\t\tdocument.body.style.overflow = 'hidden';\n\t} else if (modalElement) {\n\t\tdispatch('close');\n\t\twindow.removeEventListener('keydown', handleKeyDown);\n\n\t\tif (document.body.contains(modalElement)) {\n\t\t\tdocument.body.removeChild(modalElement);\n\t\t\tdocument.body.style.overflow = 'unset';\n\t\t}\n\t}\n\n\tonDestroy(() => {\n\t\tshow = false;\n\t\tif (modalElement) {\n\t\t\tif (document.body.contains(modalElement)) {\n\t\t\t\tdocument.body.removeChild(modalElement);\n\t\t\t\tdocument.body.style.overflow = 'unset';\n\t\t\t}\n\t\t}\n\t});\n</script>\n\n<!-- svelte-ignore a11y-click-events-have-key-events -->\n<!-- svelte-ignore a11y-no-static-element-interactions -->\n\n<div\n\tbind:this={modalElement}\n\tclass=\"modal fixed right-0 left-0 bottom-0 bg-black/60 w-full h-screen max-h-[100dvh] flex justify-center z-[9999] overflow-hidden overscroll-contain\"\n\tin:fly={{ y: 100, duration: 100 }}\n\ton:mousedown={() => {\n\t\tshow = false;\n\t}}\n>\n\t<div\n\t\tclass=\" mt-auto max-w-full w-full bg-gray-50 dark:bg-gray-900 dark:text-gray-100 {className} max-h-[100dvh] overflow-y-auto scrollbar-hidden\"\n\t\ton:mousedown={(e) => {\n\t\t\te.stopPropagation();\n\t\t}}\n\t>\n\t\t<slot />\n\t</div>\n</div>\n\n<style>\n\t.modal-content {\n\t\tanimation: scaleUp 0.1s ease-out forwards;\n\t}\n\n\t@keyframes scaleUp {\n\t\tfrom {\n\t\t\ttransform: scale(0.985);\n\t\t\topacity: 0;\n\t\t}\n\t\tto {\n\t\t\ttransform: scale(1);\n\t\t\topacity: 1;\n\t\t}\n\t}\n</style>\n","<script lang=\"ts\">\n\texport let className = 'w-4 h-4';\n\texport let strokeWidth = '1.5';\n</script>\n\n<svg\n\txmlns=\"http://www.w3.org/2000/svg\"\n\tfill=\"none\"\n\tviewBox=\"0 0 24 24\"\n\tstroke-width={strokeWidth}\n\tstroke=\"currentColor\"\n\tclass={className}\n>\n\t<path\n\t\tstroke-linecap=\"round\"\n\t\tstroke-linejoin=\"round\"\n\t\td=\"M12 6.75a.75.75 0 1 1 0-1.5.75.75 0 0 1 0 1.5ZM12 12.75a.75.75 0 1 1 0-1.5.75.75 0 0 1 0 1.5ZM12 18.75a.75.75 0 1 1 0-1.5.75.75 0 0 1 0 1.5Z\"\n\t/>\n</svg>\n"],"names":["ctx","set_data","t_value","create_if_block","insert_hydration","target","div","anchor","create_if_block_1","div2","append_hydration","div0","div1","title","$$props","content","i18n","getContext","safeOnDestroy","fn","onDestroy","derivedWithUnsubscribe","stores","unsubscribers","onUnsubscribe","cb","unsubscribe","derivedStore","derived","$storeValues","args","unsub","clientEffect","isBrowser","returned","toWritableStores","properties","result","key","propertyKey","value","writable","getOptionUpdater","options","store","styleToString","style","str","currentState","element","getCursorStyle","state","resetGlobalCursorStyle","setGlobalCursorStyle","computePaneFlexBoxStyle","defaultSize","dragState","layout","paneData","paneIndex","precision","size","flexGrow","calculateAriaValues","panesArray","pivotIndices","currentMinSize","currentMaxSize","totalMinSize","totalMaxSize","firstIndex","i","constraints","maxSize","minSize","valueMax","valueMin","valueNow","generateId","idFromProps","nanoid","LOCAL_STORAGE_DEBOUNCE_INTERVAL","PRECISION","initializeStorage","storageObject","name","err","getPaneGroupKey","autoSaveId","getPaneKey","panes","pane","id","idIsFromProps","order","loadSerializedPaneGroupState","storage","paneGroupKey","serialized","parsed","loadPaneGroupState","paneKey","savePaneGroupState","paneSizesBeforeCollapse","sizes","error","debounceMap","debounce","callback","durationMs","timeoutId","updateStorageValues","paneDataArrayStore","paneSizeBeforeCollapseStore","$paneDataArray","get","debouncedSave","clonedPaneDataArray","$paneSizeBeforeCollapse","clonedPaneSizesBeforeCollapse","removeUndefined","obj","chain","callbacks","addEventListener","event","handler","events","_event","areNumbersAlmostEqual","actual","expected","fractionDigits","compareNumbersWithTolerance","roundedActual","roundTo","roundedExpected","areArraysEqual","arrA","arrB","index","decimals","assert","expectedCondition","message","resizePane","paneConstraintsArray","initialSize","paneConstraints","collapsedSize","collapsible","newSize","getAdjustedSizeForCollapsible","halfwayPoint","adjustLayoutByDelta","delta","prevLayout","trigger","nextLayout","firstPivotIndex","secondPivotIndex","deltaApplied","prevSize","localDelta","increment","maxAvailableDelta","minAbsDelta","deltaRemaining","unsafeSize","safeSize","pivotIndex","totalSize","total","isHTMLElement","isKeyDown","isMouseEvent","isTouchEvent","defaultStorage","defaultProps","createPaneForge","props","withDefaults","direction","keyboardResizeBy","onLayout","groupId","paneDataArray","paneDataArrayChanged","paneIdToLastNotifiedSizeMap","paneSizeBeforeCollapseMap","prevDelta","$groupId","$layout","updateResizeHandleAriaValues","onMount","setResizeHandlerEventListeners","$autoSaveId","$storage","collapsePane","$prevLayout","paneSize","paneDataHelper","curr","findPaneDataIndex","$onLayout","callPaneCallbacks","getPaneSize","getPaneStyle","$dragState","isPaneExpanded","registerPane","newArr","paneA","paneB","orderA","orderB","$paneDataArrayChanged","unsafeLayout","getUnsafeDefaultLayout","validatePaneGroupLayout","registerResizeHandle","dragHandleId","$direction","$keyboardResizeBy","initialLayout","getPivotIndices","getDeltaPercentage","isHorizontal","layoutChanged","unsafePaneSize","paneConstraintsArr","startDragging","handleElement","getResizeHandleElement","initialCursorPosition","getResizeEventCursorPosition","stopDragging","unregisterPane","isPaneCollapsed","expandPane","prevPaneSize","baseSize","paneGroupStyle","paneGroupSelectors","paneGroupAttrs","$style","$selectors","unsubHandlers","getResizeHandleElementsForGroup","handle","handleId","noop","idBefore","idAfter","getResizeHandlePaneIds","unsubListener","e","setLayout","newLayout","getLayout","resizeHandleElements","resizeHandleEl","resizeHandleElement","getPaneGroupElement","handles","_a","_b","getResizeHandleElementIndex","prevPaneData","paneArray","paneId","lastNotifiedSize","onCollapse","onExpand","onResize","numPanesWithSizes","remainingSize","numRemainingPanes","nextLayoutTotalSize","accumulated","current","dir","initialDragState","movement","getDragOffsetPercentage","cursorPosition","groupElement","groupRect","groupSizeInPixels","firstTouch","PF_GROUP_CTX","setCtx","paneForge","updateOption","ctxValue","setContext","getCtx","componentName","hasContext","onLayoutChange","el","paneGroup","styleFromProps","$$value","$paneGroupStyle","div_levels","getSize","isCollapsed","isExpanded","$$invalidate","$getPaneStyle","attrs","resizeHandleAction","node","params","update","disabled","resizeHandler","isDragging","onDragging","onMove","onMouseLeave","stopDraggingAndBlur","onDraggingChange","tabIndex","resizeHandleId","isFocused","handleKeydown","nextIndex","blur_handler","focus_handler","div1_intro","create_in_transition","fly","dispatch","createEventDispatcher","show","className","modalElement","handleKeyDown","isTopModal","modals","svg","path","strokeWidth"],"mappings":"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","x_google_ignoreList":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]}